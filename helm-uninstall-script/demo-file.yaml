[8:16 PM, 5/31/2024] Lakshman Ktps: What is Helm?

Kubernetes package manager, Helm helps to control Kubernetes applications. It is possible to use Helm for definition, installation and upgrade even most complex Kubernetes apps. The packaging format it uses is called Charts which were created as a grouping of files describing a related group of Kubernetes resources.

Here are the key components and concepts of Helm:

Charts:

A package that comes with all configurations needed to install an application on a Kubernetes cluster is known as Helm chart. This includes configuration files and templates for Kubernetes resources (Deployments, Services, ConfigMaps etc.).

Repositories:

Helm charts are kept in repositories which are sets of packed charts that can be shared with other people. You may either go for public sources like the stable repository of the Helm or choose to create your own personal repositories.

Releases:

It is the case that a release is an occurrence of a graph executing in a Kubernetes block. What happens when you install a chart using Helm is that it makes a release. There exists another version for each release and Helm enables you to upgrade or rollback any releases.
[8:16 PM, 5/31/2024] Lakshman Ktps: some basic command of Helm:

Helm Commands:

helm install: Installs a chart into a Kubernetes cluster.




helm upgrade: Upgrades a release to a new chart or chart version.
helm rollback: Rolls back a release to a previous version.
helm list: Lists all releases in the cluster.
helm repo add: Adds a new chart repository.
helm repo update: Updates the local list of charts from the repositories.





[8:24 PM, 5/31/2024] Lakshman Ktps: what is Nginx-Ingress controller?

The Nginx Ingress Controller is a Kubernetes ecosystem component that manages and routes traffic from outside the cluster to appropriate services within it through Nginx. It plays the role of a first contact for external HTTP and HTTPS traffic thereby enabling exposure of Kubernetes services outside.

Key Functions of Nginx Ingress Controller

Routing: Routes traffic based on URL paths or hostnames to appropriate Kubernetes services.
Load Balancing: Spreads out load among multiple service instances to achieve high availability and reliability.
SSL/TLS Termination: Performs SSL/TLS encryption and decryption offloading, effectively managing HTTPS connections.
Authentication and Authorization: Supports various authentication mechanisms and access controls.
Custom Configuration: Enables custom Nginx configuration for specific use cases through ConfigMaps or annotations.

Installing Nginx Ingress Controller

There are several ways you can install a Nginx Ingress Controller on your Kubernetes cluster. Here, we will make use of Helm – a well-known package manager for Kubernetes which simplifies this process considerably.

Prerequisites

A running kubernetes cluster.
Helm installed on your local machine.

helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx
helm repo update
helm install my-nginx-ingress ingress-nginx/ingress-nginx
kubectl get pods -n default -l app.kubernetes.io/name=ingress-nginx    --> To verify the Installation
: What is Jenkins?

Jenkins is a highly resourceful open-source automation server used widely for continuous integration and continuous delivery (CI/CD). It helps to automate all the aspects of software development that have to do with building, testing, and deploying, thus enabling DevOps approaches.

Key Features of Jenkins

Expandable: It provides more than one thousand five hundred plugins to support any project concerning building, deploying and automating.

Building Frameworks for Distributed Systems: It can help break out the build/test loads across several machines.

Easy Installation: Packages, Docker or standalone Java applications are some forms that can be installed on different platforms.

Customizable: Has many plugins hence highly customizable.

Uses of Jenkins

Continuous Integration: This process involves building and testing the code automatically whenever a developer commits changes ensuring that the code is always ready for deployment.

Continuous Delivery: Automates application deployment making release new functionalities and updates into production environments easier.

Pipeline as Code: Better version control and easy collaboration by defining build and deployment pipelines using code

Automated Testing: Executes unit tests, integration tests and end-to-end tests through integrating with various testing frameworks.

Monitoring and Reporting: Teams will be able to quickly identify failing deployments with instant feedback on builds.

Installation of Jenkins using Helm:
helm repo add jenkins https://charts.jenkins.io
helm repo update
helm install my-jenkins jenkins/jenkins



What is SonarQube?
SonarQube is an open-source platform used for continuous inspection of code quality. It performs static code analysis, providing detailed reports on code duplication, coding standards, code coverage, bugs, code smells, and security vulnerabilities.

Key Features of SonarQube
Static Code Analysis: Analyzes code to find issues without executing the code.
Multi-Language Support: Supports a wide range of programming languages.
Quality Gates: Define a set of conditions that code must meet before it can be considered of acceptable quality.
Integrations: Integrates with CI/CD tools like Jenkins, Azure DevOps, GitHub Actions, etc.
Extensible: Can be extended with plugins for additional functionalities.

Uses of SonarQube
Code Quality Management: Helps maintain high standards of code quality by identifying and rectifying issues early in the development process.
Continuous Inspection: Integrates with CI/CD pipelines to provide continuous feedback on code quality.
Technical Debt Management: Assists in identifying and managing technical debt.
Security Vulnerability Detection: Detects security vulnerabilities in the codebase.
Compliance: Ensures that the code adheres to industry standards and regulations.

Installing SonarQube Using Helm
helm repo add sonarqube https://SonarSource.github.io/helm-chart-sonarqube
helm repo update
helm install my-sonarqube sonarqube/sonarqube

Customise sonarqube with available databse





yum install postgresql



To Login into database:

psql -h <host> -p <port> -U <username> -d <database>
       psql -h lucky-database.c5q68so8ev62.us-west-2.rds.amazonaws.com -p 5432 -U postgres -d sampleDB
       
       ➜  ~ psql -h lucky-db.cjoco4yuq5x6.ap-south-1.rds.amazonaws.com -p 5432 -U postgres -d luckydb
            Password for user postgres:
            psql (14.12 (Homebrew), server 16.2)
            WARNING: psql major version 14, server major version 16.
                     Some psql features might not work.
            SSL connection (protocol: TLSv1.3, cipher: TLS_AES_256_GCM_SHA384, bits: 256, compression: off)
            Type "help" for help.

            luckydb=>
            luckydb=>
            
            
Create new Database:


Before creating the database need to Alter the TABLESPACE for specific user:
   
   ALTER TABLESPACE pg_default OWNER TO postgres;


CREATE DATABASE luckyDB
WITH 
    OWNER = postgres
    TEMPLATE = template0
    ENCODING = 'UTF8'
    STRATEGY = default
    COLLATION_VERSION = '153.0'
    TABLESPACE = pg_default
    ALLOW_CONNECTIONS = true
    IS_TEMPLATE = false;



Create new user :


CREATE USER <username> [ WITH PASSWORD '<password>' | [ CREATEDB ] | [ NOCREATEDB ] | [ CREATEUSER ] | [ NOCREATEUSER ] | [ INHERIT ] | [ NOINHERIT ] | [ LOGIN ] | [ NOLOGIN ] | [ CONNECTION LIMIT <connlimit> ] | [ ENCRYPTED PASSWORD '<encrypted_password>' ] ];


CREATE USER lucky WITH PASSWORD 'lucky1225' CREATEDB LOGIN CONNECTION LIMIT 50;



To prevent database users from creating objects in the public schema, do the following:

         REVOKE CREATE ON SCHEMA public FROM PUBLIC;


Revoke all privileges from the PUBLIC schema on this new database.

        REVOKE ALL ON DATABASE luckydb FROM public;

Give database users that have this role the ability to connect to the database.

        GRANT CONNECT ON DATABASE luckydb TO lucky;

Grant all users with the lab_tech role all privileges on this database.
        GRANT ALL PRIVILEGES ON DATABASE luckydb TO lucky;


Table Creation:

creating new schema: CREATE SCHEMA lucky;

CREATE TABLE lucky.customers (
    customer_id SERIAL PRIMARY KEY,
    first_name VARCHAR(50) NOT NULL,
    last_name VARCHAR(50) NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

Insert data into table:

INSERT INTO lucky.customers (first_name, last_name, email)
VALUES 
('John', 'Doe', 'john.doe@example.com'),
('Jane', 'Smith', 'jane.smith@example.com'),
('Alice', 'Johnson', 'alice.johnson@example.com'),
('Bob', 'Brown', 'bob.brown@example.com');



INSERT INTO lucky.customers
(customer_id, first_name, last_name, email, created_at)
VALUES(6, 'siri', 'Hanumanthu', 'siri.hanumanth@example.com', '2024-06-01 10:39:15.752');

            
To list databses in postgress:
  psql -h lucky-db.cjoco4yuq5x6.ap-south-1.rds.amazonaws.com -p 5432 -U postgres -d luckydb -l
  or 
  \l+
  
To list users in postgres: \du
  

To check Roles:

SELECT rolname FROM pg_roles;
